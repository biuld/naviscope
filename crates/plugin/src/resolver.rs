use crate::graph::{CodeGraph, ResolvedUnit};
use crate::model::ParsedFile;
use naviscope_api::models::graph::DisplayGraphNode;
use naviscope_api::models::graph::NodeKind;
use naviscope_api::models::symbol::{FqnId, Range};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

use tree_sitter::Tree;

/// Core interface for resolving a symbol at a specific position in a document.
pub trait SemanticResolver: Send + Sync {
    /// Resolve a symbol at a specific position in a document (local view)
    fn resolve_at(
        &self,
        tree: &Tree,
        source: &str,
        line: usize,
        byte_col: usize,
        index: &dyn CodeGraph,
    ) -> Option<naviscope_api::models::SymbolResolution>;

    /// Find nodes in the global graph matching a resolution result (global view)
    fn find_matches(
        &self,
        index: &dyn CodeGraph,
        res: &naviscope_api::models::SymbolResolution,
    ) -> Vec<FqnId>;

    /// Resolve the type(s) of a symbol (e.g., return type of a method, type of a field)
    fn resolve_type_of(
        &self,
        index: &dyn CodeGraph,
        res: &naviscope_api::models::SymbolResolution,
    ) -> Vec<naviscope_api::models::SymbolResolution>;

    /// Find implementations or overrides of a symbol (global view)
    fn find_implementations(
        &self,
        index: &dyn CodeGraph,
        res: &naviscope_api::models::SymbolResolution,
    ) -> Vec<FqnId>;
}

pub trait LspParser: Send + Sync {
    fn parse(&self, source: &str, old_tree: Option<&Tree>) -> Option<Tree>;

    fn extract_symbols(&self, tree: &Tree, source: &str) -> Vec<DisplayGraphNode>;

    /// Maps a language-specific symbol kind string to an LSP SymbolKind
    fn symbol_kind(&self, kind: &NodeKind) -> lsp_types::SymbolKind;

    /// Find occurrences of a symbol within a single file's AST.
    fn find_occurrences(
        &self,
        source: &str,
        tree: &Tree,
        target: &naviscope_api::models::SymbolResolution,
    ) -> Vec<Range>;
}

/// Project context generated by BuildResolver during the first phase
#[derive(Debug, Clone, Default)]
pub struct ProjectContext {
    /// Mapping from path prefixes to module IDs (e.g., "/project/app" -> "module::app")
    pub path_to_module: HashMap<PathBuf, String>,

    /// Third-party library asset paths (JARs, node_modules, etc.)
    pub external_assets: Vec<PathBuf>,

    /// SDK/Runtime asset paths (Builtin libs)
    pub builtin_assets: Vec<PathBuf>,

    /// Mapping from symbol prefixes (e.g. "java.lang") to asset paths
    pub asset_routes: HashMap<String, Vec<PathBuf>>,
}

impl ProjectContext {
    pub fn new() -> Self {
        Self {
            path_to_module: HashMap::new(),
            external_assets: Vec::new(),
            builtin_assets: Vec::new(),
            asset_routes: HashMap::new(),
        }
    }

    /// Finds the best matching module ID for a given file path
    pub fn find_module_for_path(&self, path: &Path) -> Option<String> {
        let mut current = path.to_path_buf();
        while let Some(parent) = current.parent() {
            if let Some(id) = self.path_to_module.get(parent) {
                return Some(id.clone());
            }
            current = parent.to_path_buf();
        }
        None
    }
}

/// Responsible for resolution logic at the build tool level
pub trait BuildResolver: Send + Sync {
    /// Resolves build files into graph operations and project context
    fn resolve(
        &self,
        files: &[&ParsedFile],
    ) -> Result<(ResolvedUnit, ProjectContext), Box<dyn std::error::Error + Send + Sync>>;
}

/// Responsible for resolution logic at the language level
pub trait LangResolver: Send + Sync {
    /// Resolves source files into graph operations using the provided context
    fn resolve(
        &self,
        file: &ParsedFile,
        context: &ProjectContext,
    ) -> Result<ResolvedUnit, Box<dyn std::error::Error + Send + Sync>>;
}

/// A generic trait for semantic scopes in any programming language.
/// `C` represents the language-specific resolution context.
pub trait SemanticScope<C>: Send + Sync {
    /// Resolve a name within this specific scope.
    /// Returns:
    /// - `Some(Ok(res))` if the symbol is found.
    /// - `Some(Err(()))` if the symbol is NOT found and searching should stop (shadowing/short-circuit).
    /// - `None` if the symbol is NOT found and searching should continue in the next scope.
    fn resolve(
        &self,
        name: &str,
        context: &C,
    ) -> Option<Result<naviscope_api::models::SymbolResolution, ()>>;

    /// Returns the name of the scope for debugging purposes.
    fn name(&self) -> &'static str;
}

pub trait ExternalResolver: Send + Sync {
    /// 1. Asset Indexing: Pre-scan asset content, returns top-level symbols/packages
    /// Used by the engine to build the route table.
    fn index_asset(
        &self,
        asset: &Path,
    ) -> std::result::Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>>;

    /// 2. Code Stubbing: Extract symbol definitions (without logic) from asset.
    /// Used for background population of External nodes' metadata.
    fn generate_stub(
        &self,
        fqn: &str,
        asset: &Path,
    ) -> std::result::Result<crate::model::IndexNode, Box<dyn std::error::Error + Send + Sync>>;

    /// 3. Source Resolution: Extract full parse results from source asset.
    /// Triggered when the user requests Go to Definition.
    fn resolve_source(
        &self,
        fqn: &str,
        source_asset: &Path,
    ) -> std::result::Result<
        crate::model::GlobalParseResult,
        Box<dyn std::error::Error + Send + Sync>,
    >;
}
