pub mod gradle;
pub mod java;

use crate::error::Result;
use crate::project::resolver::ResolvedUnit;
use crate::project::scanner::ParsedFile;
use std::collections::HashMap;
use std::path::{Path, PathBuf};

/// Project context generated by BuildResolver during the first phase
#[derive(Debug, Clone)]
pub struct ProjectContext {
    /// Mapping from path prefixes to module IDs (e.g., "/project/app" -> "module::app")
    pub path_to_module: HashMap<PathBuf, String>,
}

impl ProjectContext {
    pub fn new() -> Self {
        Self {
            path_to_module: HashMap::new(),
        }
    }

    /// Finds the best matching module ID for a given file path
    pub fn find_module_for_path(&self, path: &Path) -> Option<String> {
        let mut current = path.to_path_buf();
        while let Some(parent) = current.parent() {
            if let Some(id) = self.path_to_module.get(parent) {
                return Some(id.clone());
            }
            current = parent.to_path_buf();
        }
        None
    }
}

/// Responsible for resolution logic at the build tool level
pub trait BuildResolver: Send + Sync {
    /// Resolves build files into graph operations and project context
    fn resolve(&self, files: &[&ParsedFile]) -> Result<(ResolvedUnit, ProjectContext)>;
}

/// Responsible for resolution logic at the language level
pub trait LangResolver: Send + Sync {
    /// Resolves source files into graph operations using the provided context
    fn resolve(&self, file: &ParsedFile, context: &ProjectContext) -> Result<ResolvedUnit>;
}
